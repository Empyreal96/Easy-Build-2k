// xmemory internal header (from <memory>)
#pragma once
#ifndef _XMEMORY_
#define _XMEMORY_
#include <cstdlib>
#include <new>
#include <xutility>

#pragma pack(push,8)
#pragma warning(push,3)

 #pragma warning(disable: 4100)

#ifndef _FARQ	/* specify standard memory model */
 #define _FARQ
 #define _PDFT	ptrdiff_t
 #define _SIZT	size_t
#endif

 #define _CPOINTER_X(T, A)		\
	typename A::_TEMPLATE_MEMBER rebind<T>::other::const_pointer
 #define _CREFERENCE_X(T, A)	\
	typename A::_TEMPLATE_MEMBER rebind<T>::other::const_reference
 #define _POINTER_X(T, A)	\
	typename A::_TEMPLATE_MEMBER rebind<T>::other::pointer
 #define _REFERENCE_X(T, A)	\
	typename A::_TEMPLATE_MEMBER rebind<T>::other::reference

_STD_BEGIN
		// TEMPLATE FUNCTION _Allocate
template<class _Ty> inline
	_Ty _FARQ *_Allocate(_SIZT _Count, _Ty _FARQ *)
	{	// allocate storage for _Count elements of type _Ty
	return ((_Ty _FARQ *)operator new(_Count * sizeof (_Ty)));
	}

		// TEMPLATE FUNCTION _Construct
template<class _T1,
	class _T2> inline
	void _Construct(_T1 _FARQ *_Ptr, const _T2& _Val)
	{	// construct object at _Ptr with value _Val
	new ((void _FARQ *)_Ptr) _T1(_Val);
	}

		// TEMPLATE FUNCTION _Destroy
template<class _Ty> inline
	void _Destroy(_Ty _FARQ *_Ptr)
	{	// destroy object at _Ptr
	_DESTRUCTOR(_Ty, _Ptr);
	}

template<> inline
	void _Destroy(char _FARQ *)
	{	// destroy a char (do nothing)
	}

template<> inline
	void _Destroy(wchar_t _FARQ *)
	{	// destroy a wchar_t (do nothing)
	}

		// TEMPLATE CLASS allocator
template<class _Ty>
	class allocator
	{	// generic allocator for objects of class _Ty
public:
	typedef _SIZT size_type;
	typedef _PDFT difference_type;
	typedef _Ty _FARQ *pointer;
	typedef const _Ty _FARQ *const_pointer;
	typedef _Ty _FARQ& reference;
	typedef const _Ty _FARQ& const_reference;
	typedef _Ty value_type;

	template<class _Other>
		struct rebind
		{	// convert an allocator<_Ty> to an allocator <_Other>
		typedef allocator<_Other> other;
		};

	pointer address(reference _Val) const
		{	// return address of mutable _Val
		return (&_Val);
		}

	const_pointer address(const_reference _Val) const
		{	// return address of nonmutable _Val
		return (&_Val);
		}

	allocator()
		{	// construct default allocator (do nothing)
		}

	allocator(const allocator<_Ty>&)
		{	// construct by copying (do nothing)
		}

	template<class _Other>
		allocator(const allocator<_Other>&)
		{	// construct from a related allocator (do nothing)
		}

	template<class _Other>
		allocator<_Ty>& operator=(const allocator<_Other>&)
		{	// assign from a related allocator (do nothing)
		return (*this);
		}

	template<class _Other>
		pointer allocate(size_type _Count, const _Other *)
		{	// allocate array of _Count elements, ignore hint
			// don't call _Allocate directly, in case class is dllimport
		return (allocate(_Count));
		}

	pointer allocate(size_type _Count)
		{	// allocate array of _Count elements
		return (_Allocate(_Count, (pointer)0));
		}

	void deallocate(pointer _Ptr, size_type)
		{	// deallocate object at _Ptr, ignore size
		operator delete(_Ptr);
		}

	void construct(pointer _Ptr, const _Ty& _Val)
		{	// construct object at _Ptr with value _Val
		_Construct(_Ptr, _Val);
		}

	void destroy(pointer _Ptr)
		{	// destroy object at _Ptr
		_Destroy(_Ptr);
		}

	_SIZT max_size() const
		{	// estimate maximum array size
		_SIZT _Count = (_SIZT)(-1) / sizeof (_Ty);
		return (0 < _Count ? _Count : 1);
		}
	};

		// allocator TEMPLATE OPERATORS
template<class _Ty,
	class _Other> inline
	bool operator==(const allocator<_Ty>&, const allocator<_Other>&)
	{	// test for allocator equality (always true)
	return (true);
	}

template<class _Ty,
	class _Other> inline
	bool operator!=(const allocator<_Ty>&, const allocator<_Other>&)
	{	// test for allocator inequality (always false)
	return (false);
	}

		// CLASS allocator<void>
template<> class _CRTIMP2 allocator<void>
	{	// generic allocator for type void
public:
	typedef void _Ty;
	typedef _Ty _FARQ *pointer;
	typedef const _Ty _FARQ *const_pointer;
	typedef _Ty value_type;

	template<class _Other>
		struct rebind
		{	// convert an allocator<void> to an allocator <_Other>
		typedef allocator<_Other> other;
		};

	allocator()
		{	// construct default allocator (do nothing)
		}

	allocator(const allocator<_Ty>&)
		{	// construct by copying (do nothing)
		}

	template<class _Other>
		allocator(const allocator<_Other>&)
		{	// construct from related allocator (do nothing)
		}

	template<class _Other>
		allocator<_Ty>& operator=(const allocator<_Other>&)
		{	// assign from a related allocator (do nothing)
		return (*this);
		}
	};

		// TEMPLATE FUNCTION _Destroy_range
template<class _Ty,
	class _Alloc> inline
	void _Destroy_range(_Ty *_First, _Ty *_Last, _Alloc& _Al)
	{	// destroy [_First, _Last)
	_Destroy_range(_First, _Last, _Al, _Ptr_cat(_First, _Last));
	}

template<class _Ty,
	class _Alloc> inline
	void _Destroy_range(_Ty *_First, _Ty *_Last, _Alloc& _Al,
		_Nonscalar_ptr_iterator_tag)
	{	// destroy [_First, _Last), arbitrary type
	for (; _First != _Last; ++_First)
		_Al.destroy(_First);
	}

template<class _Ty,
	class _Alloc> inline
	void _Destroy_range(_Ty *_First, _Ty *_Last, _Alloc& _Al,
		_Scalar_ptr_iterator_tag)
	{	// destroy [_First, _Last), scalar type (do nothing)
	}
_STD_END

  #pragma warning(default: 4100)
#pragma warning(pop)
#pragma pack(pop)

#endif /* _XMEMORY_ */

/*
* Copyright (c) 1992-2001 by P.J. Plauger.  ALL RIGHTS RESERVED.
 * Consult your license regarding permissions and restrictions.
 */

/*
 * This file is derived from software bearing the following
 * restrictions:
 *
 * Copyright (c) 1994
 * Hewlett-Packard Company
 *
 * Permission to use, copy, modify, distribute and sell this
 * software and its documentation for any purpose is hereby
 * granted without fee, provided that the above copyright notice
 * appear in all copies and that both that copyright notice and
 * this permission notice appear in supporting documentation.
 * Hewlett-Packard Company makes no representations about the
 * suitability of this software for any purpose. It is provided
 * "as is" without express or implied warranty.
 V3.10:0009 */
